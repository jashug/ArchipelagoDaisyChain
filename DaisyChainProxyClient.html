<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AP DaisyChain Client</title>
    <style>
        /* Generic better CSS defaults, based in large part on https://www.joshwcomeau.com/css/custom-css-reset/ */
        *,
        *:before,
        *:after {
            box-sizing: border-box;
        }

        body {
            line-height: 1.6
        }

        @media (prefers-reduced-motion: no-preference) {
            html {
                interpolate-size: allow-keywords;
            }
        }
    </style>
    <style>
        h1,
        h2,
        h3 {
            margin: 0
        }

        .server {
            border: 1px solid black;
            padding-inline: 0.5em;
            padding-block: 0.2em;
        }

        .server-inputs {
            display: flex;
            flex-flow: row wrap;
            gap: 0em 0.5em;
        }

        .server-address {
            width: 25ch
        }

        .username,
        .password {
            width: 16ch
        }

        .item-table-container {
            display: flex;
            flex-flow: row wrap;
        }

        .item-table-container>div {
            flex: 350px
        }
    </style>
</head>

<body>
    <noscript>This page won't do anything with javascript disabled.</noscript>
    <h1>Archipelago Daisy Chain Proxy Client</h1>
    <!-- TODO: Add link to github repository -->

    <h3>Past:</h3>
    <div class="server" id="past-server">
        <div class="server-inputs">
            <label for="past-address">Server:
                <input type="url" id="past-address" class="server-address"
                    placeholder="wss://archipelago.gg:port" /></label>
            <label for="past-slot">Slot:
                <input type="text" id="past-slot" class="username" placeholder="SlotName" /></label>
            <label for="past-password">Password:
                <input type="password" id="past-password" class="password" placeholder="password" /></label>
        </div>
        <div>
            <button id="past-button">Connect</button>
            <span id="past-status" class="connection-info">Not Connected</span>
        </div>
    </div>
    <h3>Present:</h3>
    <div class="server" id="present-server">
        <div class="server-inputs">
            <label for="present-address">Server:
                <input type="url" id="present-address" class="server-address"
                    placeholder="wss://archipelago.gg:port" /></label>
            <label for="present-slot">Slot:
                <input type="text" id="present-slot" class="username" placeholder="SlotName" /></label>
            <label for="present-password">Password:
                <input type="password" id="present-password" class="password" placeholder="password" /></label>
        </div>
        <div>
            <button id="present-button">Connect</button>
            <span id="present-status" class="connection-info">Not Connected</span>
        </div>
    </div>
    <h3>Future:</h3>
    <div class="server" id="future-server">
        <div class="server-inputs">
            <label for="future-address">Server:
                <input type="url" id="future-address" class="server-address"
                    placeholder="wss://archipelago.gg:port" /></label>
            <label for="future-slot">Slot:
                <input type="text" id="future-slot" class="username" placeholder="SlotName" /></label>
            <label for="future-password">Password:
                <input type="password" id="future-password" class="password" placeholder="password" /></label>
        </div>
        <div>
            <button id="future-button">Connect</button>
            <span id="future-status" class="connection-info">Not Connected</span>
        </div>
    </div>

    <div class="item-table-container">
        <div id="items-from-past">
            <h3>Items from Past</h3>
            <div id="items-from-past-rows"></div>
        </div>
        <div id="items-from-future">
            <h3>Items from Future</h3>
            <div id="items-from-future-rows"></div>
        </div>
        <div id="items-for-other">
            <h3>Items for Others</h3>
            <div id="items-for-other-rows"></div>
        </div>
        <div id="passthrough">
            <h3>Items Passed Through</h3>
            <div id="items-passthrough-rows"></div>
        </div>
    </div>

    <script>"use strict";
        /**
         * Takes an array, and performs an in-place random permutation.
         * Copied from https://stackoverflow.com/a/2450976/2644368
        */
        function shuffle(array) {
            let currentIndex = array.length;

            // While there remain elements to shuffle...
            while (currentIndex != 0) {

                // Pick a remaining element...
                let randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;

                // And swap it with the current element.
                [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
            }
        };

        /**
         * Not currently used by the server, may be used in the future for locking slots.
         * I don't see much problem with reusing it for everyone using this client,
         * but it could also be randomly generated and stored in localStorage in the future.
        */
        const GAME_NAME = "DaisyChain Proxy";
        const CLIENT_UUID = "e42b6a67-536d-43db-a714-96482da24ec2";

        const DATA_PACKAGE_STORE_NAME = "DataPackage";

        /** a promise for either null or an IDBDatabase */
        const cacheDb = new Promise((resolve, reject) => {
            const request = indexedDB.open("archipelagoCache");
            request.onerror = () => {
                console.log("Could not open IndexedDB for data package cache");
                resolve(null);
            };
            request.onsuccess = (event) => resolve(event.target.result);
            request.onupgradeneeded = () => {
                const db = event.target.result;
                db.createObjectStore(DATA_PACKAGE_STORE_NAME, { keyPath: ["game", "checksum"] });
            };
        });

        /** Returns undefined if key not found */
        async function getDataPackage({ game, checksum }) {
            const db = await cacheDb;
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(DATA_PACKAGE_STORE_NAME);
                transaction.onabort = () => reject(new Error("transaction failed"));
                const objectStore = transaction.objectStore(DATA_PACKAGE_STORE_NAME);
                const request = objectStore.get([game, checksum]);
                request.onsuccess = (event) => resolve(event.target.result);
            });
        };

        async function putDataPackage(record) {
            const db = await cacheDb;
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(DATA_PACKAGE_STORE_NAME, "readwrite");
                transaction.onabort = (event) => reject(event.target.error);
                const objectStore = transaction.objectStore(DATA_PACKAGE_STORE_NAME);
                const request = objectStore.put(record);
                request.onsuccess = (event) => resolve(event.target.result);
            });
        };

        function sumOfLogic(logic) {
            let items = 0;
            let locations = 0;
            for (const block of logic) {
                items += block.items;
                locations += block.locations.length;
            }
            return { items, locations };
        }

        function fromRange(id, { start, count }) {
            const index = id - start;
            if (0 <= index && index < count) {
                return { index };
            } else {
                return null;
            }
        }

        function toRange(index, { start, count }) {
            console.assert(0 <= index && index < count);
            return index + start;
        }

        function logicEqual({ nonce: nonce1, logic: logic1 }, { nonce: nonce2, logic: logic2 }) {
            if (nonce1 !== nonce2) return false;
            if (logic1.length !== logic2.length) return false;
            for (const blockIndex of logic1.keys()) {
                const block1 = logic1[blockIndex];
                const block2 = logic2[blockIndex];
                if (block1.items !== block2.items) return false;
                if (block1.locations.length !== block2.locations.length) return false;
                for (const rowIndex of block1.locations.keys()) {
                    const row1 = new Set(block1.locations[rowIndex]);
                    const row2 = new Set(block2.locations[rowIndex]);
                    if (row1.symmetricDifference(row2).size !== 0) return false;
                }
            }
            return true;
        }

        const ServerStateKind = {
            GOOD: 'good',
            BAD: 'bad',
            NEUTRAL: 'neutral',
        };

        const HAS_PROTOCOL = /^wss?:\/\//;

        /** An object managing a server, such as the Past server slot */
        class ServerSlot {
            // Using public fields is slightly more flexible,
            // and I don't need the encapsulation guarantees of private fields.
            connectionTarget = null;
            liveConnection = null;
            socket = null;
            credentials = null;
            roomInfo = null;
            authenticated = null;
            onurlchange;
            onstatechange;
            connectPast;
            connectFuture;

            constructor({ onurlchange, onstatechange, setconnect, connectPast, connectFuture }) {
                this.onurlchange = onurlchange;
                this.onstatechange = onstatechange;
                setconnect(this.connect.bind(this));
                this.connectPast = connectPast;
                this.connectFuture = connectFuture;
                this.disconnect();
            }

            disconnect() {
                this.liveConnection?.abort()
                this.connectionTarget = null;
                this.onurlchange(null);
                this.onstatechange(ServerStateKind.NEUTRAL, "Disconnected");
            }

            // N.B. This behaves very similar to a setter for this.connectionTarget
            connect(connectionTarget) {
                if (!connectionTarget) {
                    this.disconnect();
                    return;
                }
                const stringURL = connectionTarget.url.toString();
                if (!this.connectionTarget ||
                    this.connectionTarget.url !== stringURL ||
                    this.connectionTarget.slotName !== connectionTarget.slotName ||
                    this.connectionTarget.password !== connectionTarget.password) {
                    // We are changing connectionTarget
                    this.liveConnection?.abort();
                    this.connectionTarget = connectionTarget;
                    this.onurlchange(this.connectionTarget);
                } else if (this.liveConnection) {
                    // Don't need to disconnect and reconnect if we are already connected to the right place.
                    return;
                }
                const candidateURL = URL.parse(HAS_PROTOCOL.test(stringURL) ? stringURL : "wss://" + stringURL);
                if (!candidateURL || candidateURL.hash) {
                    this.onstatechange(ServerStateKind.BAD, "Invalid URL");
                    return;
                }
                this.liveConnection = new AbortController();
                this.liveConnection.signal.addEventListener("abort", () => {
                    this.liveConnection = null;
                    this.socket.close();
                    this.socket = null;
                }, { once: true });
                this.socket = this.#createSocket(candidateURL);
                this.onstatechange(ServerStateKind.NEUTRAL, "Connecting...");
            }

            #createSocket(url) {
                const socket = new WebSocket(url);
                socket.addEventListener("close", this.#closeHandler.bind(this), {
                    once: true,
                    signal: this.liveConnection.signal,
                });
                // We don't actually have anything to do onopen: wait for the server to send RoomInfo.
                socket.addEventListener("message", this.#messageHandler.bind(this), {
                    signal: this.liveConnection.signal,
                });
                return socket;
            }

            #closeHandler() {
                if (this.roomInfo) {
                    // We recieved the RoomInfo packet: this was an anomalous closure
                    this.liveConnection.abort();
                    this.onstatechange(ServerStateKind.BAD, "Connection closed unexpectedly");
                    return;
                }
                let url = new URL(this.socket.url);
                if (url.protocol === "ws:" || HAS_PROTOCOL.test(this.connectionTarget.url)) {
                    this.liveConnection.abort();
                    this.onstatechange(ServerStateKind.BAD, "Unable to connect");
                    return;
                }
                // Fall back to ws from wss
                url.protocol = "ws:";
                this.socket = this.#createSocket(url);
            }

            getNextDataPackage() {
                if (this.roomInfo.gamesToFetch.length === 0) {
                    console.assert(this.roomInfo.games.every((game) => this.roomInfo.dataPackages.has(game)));
                    this.socket.send(JSON.stringify([{
                        cmd: "Connect",
                        name: this.connectionTarget.slotName,
                        game: GAME_NAME,
                        password: this.connectionTarget.password,
                        slot_data: true,
                        items_handling: 0b111 /* All items */,
                        uuid: CLIENT_UUID,
                        tags: ["NoText"],
                        version: { major: 0, minor: 6, build: 5, class: "Version" },
                    }]));
                    this.onstatechange(ServerStateKind.NEUTRAL, "Authenticating...");
                    return;
                }
                const game = this.roomInfo.gamesToFetch.pop();
                console.assert(!this.roomInfo.dataPackages.has(game));
                const requestFromServer = () => {
                    this.socket.send(JSON.stringify([{
                        cmd: "GetDataPackage",
                        games: [game],
                    }]));
                };
                const checksum = this.roomInfo.dataPackageChecksums.get(game);
                if (checksum) {
                    const signal = this.liveConnection.signal;
                    getDataPackage({ game, checksum }).then((result) => {
                        if (signal.aborted) return;
                        if (result) {
                            this.roomInfo.dataPackages.set(game, {
                                locationIdToName: result.locationIdToName,
                                itemIdToName: result.itemIdToName
                            });
                            this.getNextDataPackage();
                        } else {
                            requestFromServer();
                        }
                    }, (error) => {
                        if (signal.aborted) return;
                        this.liveConnection.abort();
                        this.onstatechange(ServerStateKind.BAD, "Error getting data package from cache");
                    });
                } else {
                    requestFromServer();
                }
            }

            #messageHandler(event) {
                // Server could send a binary message, which would turn into a Blob or ArrayBuffer here.
                // Shouldn't happen, ignore for now.
                const handlers = new Map([
                    ["RoomInfo", this.#roomInfoHandler],
                    ["ConnectionRefused", (packet) => {
                        this.liveConnection.abort();
                        this.onstatechange(ServerStateKind.BAD, `Connection refused: ${packet.errors}`);
                    }],
                    ["Connected", this.#connectedPacketHandler],
                    ["ReceivedItems", (packet) => { this.authenticated.receiveItems(packet.index, packet.items); }],
                    ["LocationInfo", (packet) => { this.authenticated.scoutLocations(packet.locations); }],
                    ["RoomUpdate", (packet) => {
                        // Can include permissions, hint_cost, location_check_points, hint_points, players, checked_locations,
                        // of which we only care about checked_locations.
                        if (packet.checked_locations !== undefined) {
                            this.authenticated.addCheckedLocations(packet.checked_locations);
                        }
                    }],
                    ["PrintJSON", (packet) => { /* We are ignoring text messages */ }],
                    ["DataPackage", (packet) => {
                        for (const [game, data] of Object.entries(packet.data.games)) {
                            const itemIdToName = new Map(Object.entries(data.item_name_to_id).map(([name, id]) => [id, name]));
                            const locationIdToName = new Map(Object.entries(data.location_name_to_id).map(([name, id]) => [id, name]));
                            this.roomInfo.dataPackages.set(game, { itemIdToName, locationIdToName });
                            if (data.checksum) {
                                putDataPackage({ game: game, checksum: data.checksum, itemIdToName, locationIdToName });
                            }
                        }
                        this.getNextDataPackage();
                    }],
                    ["Bounced", (packet) => { /* Not expecting any bounces */ }],
                    ["InvalidPacket", (packet) => {
                        console.log(`Server complained of invalid ${packet.cmd} packet (${packet.type}): ${packet.text}`);
                        // Should this abort the connection?
                    }],
                    ["Retrieved", (packet) => {
                        const hints = packet.keys[this.authenticated.hintKey]
                        if (hints !== undefined) {
                            this.authenticated.setHints(hints);
                        }
                    }],
                    ["SetReply", (packet) => {
                        if (packet.key === this.authenticated.hintKey) {
                            this.authenticated.setHints(packet.value);
                        }
                    }],
                ]);
                const defaultHandler = (packet) => {
                    console.log(`Unrecognized packet type ${packet.cmd}`);
                };
                const packets = JSON.parse(event.data);
                const signal = this.liveConnection.signal;
                for (const packet of packets) {
                    (handlers.get(packet.cmd) || defaultHandler).call(this, packet);
                    if (signal.aborted) return;
                }
            }

            #roomInfoHandler(packet) {
                if (this.roomInfo) {
                    this.liveConnection.abort();
                    this.onstatechange(ServerStateKind.BAD, "Protocol violation: double RoomInfo packet");
                    return;
                }
                shuffle(packet.games);
                this.roomInfo = {
                    games: packet.games,
                    gamesToFetch: packet.games,
                    dataPackages: new Map(),
                    dataPackageChecksums: new Map(Object.entries(packet.datapackage_checksums))
                }
                this.liveConnection.signal.addEventListener("abort",
                    () => { this.roomInfo = null },
                    { once: true },
                );
                this.getNextDataPackage();
                this.onstatechange(ServerStateKind.NEUTRAL, "Downloading data packages...");
            }

            #connectedPacketHandler(packet) {
                if (this.authenticated) {
                    this.liveConnection.abort();
                    this.onstatechange(ServerStateKind.BAD, "Protocol violation: double connected packet");
                    return;
                }
                const slotData = packet.slot_data;
                const slotInfo = new Map(Object.entries(packet.slot_info));
                const evict = () => {
                    this.liveConnection.abort();
                    this.onstatechange(ServerStateKind.BAD, "Logic mismatch");
                };
                let gameStatePast = null;
                if (this.connectPast) {
                    gameStatePast = this.connectPast({
                        nonce: slotData.past_nonce,
                        logic: slotData.past_logic,
                        spoilers: slotData.past_item_spoilers,
                        dataPackages: this.dataPackages,
                        slotInfo: this.slotInfo,
                        callbacks: {
                            evict,
                            check: (locations) => {
                                const locationIds = Array.from(locations.values().map((index) =>
                                    toRange(index, this.authenticated.idRanges.past.location)
                                ));
                                this.socket.send(JSON.stringify([
                                    { cmd: "LocationScouts", locations: locationIds, create_as_hint: 0 },
                                    { cmd: "LocationChecks", locations: locationIds },
                                ]));
                            },
                        },
                    });
                    if (!gameStatePast) {
                        this.liveConnection.abort();
                        this.onstatechange("Logic mismatch");
                        return;
                    }
                    this.liveConnection.signal.addEventListener("abort",
                        gameStatePast.disconnect.bind(gameStatePast),
                        { once: true },
                    );
                }
                let gameStateFuture = null;
                if (this.connectFuture) {
                    gameStateFuture = this.connectFuture({
                        nonce: slotData.nonce,
                        logic: slotData.future_logic,
                        spoilers: slotData.future_item_spoilers,
                        dataPackages: this.dataPackages,
                        slotInfo: this.slotInfo,
                        callbacks: {
                            evict,
                            check: (locations) => {
                                const locationIds = Array.from(locations.values().map((index) =>
                                    toRange(index, this.authenticated.idRanges.future.location)
                                ));
                                this.socket.send(JSON.stringify([
                                    { cmd: "LocationScouts", locations: locationIds, create_as_hint: 0 },
                                    { cmd: "LocationChecks", locations: locationIds },
                                ]));
                            },
                        },
                    });
                    if (!gameStateFuture) {
                        this.liveConnection.abort();
                        this.onstatechange(ServerStateKind.BAD, "Logic mismatch");
                        return;
                    }
                    this.liveConnection.signal.addEventListener("abort",
                        gameStateFuture.disconnect.bind(gameStateFuture),
                        { once: true },
                    );
                }
                this.authenticated = new ServerSlot.#AuthBlock(packet.team, packet.slot, slotData, gameStatePast, gameStateFuture);
                this.authenticated.gameStatePast?.resendChecks();
                this.authenticated.gameStateFuture?.resendChecks();
                this.liveConnection.signal.addEventListener("abort",
                    () => { this.authenticated = null; },
                    { once: true },
                );
                this.authenticated.addCheckedLocations(packet.checked_locations);
                this.onstatechange(ServerStateKind.GOOD, "Connected");
            }

            static #AuthBlock = class {
                teamNumber;
                slotNumber;
                hintKey;
                itemIndex = 0;
                gameStatePast;
                gameStateFuture;
                idRanges;

                constructor(teamNumber, slotNumber, slotData, gameStatePast, gameStateFuture) {
                    this.teamNumber = teamNumber;
                    this.slotNumber = slotNumber;
                    this.hintKey = `_read_hints_${teamNumber}_${slotNumber}`;
                    this.gameStatePast = gameStatePast;
                    this.gameStateFuture = gameStateFuture;
                    // Because past logic gives the transpose matrix, swap items and locations.
                    const { items: past_location_count, locations: past_item_count } = sumOfLogic(slotData.past_logic);
                    const { items: future_item_count, locations: future_location_count } = sumOfLogic(slotData.future_logic);
                    this.idRanges = {
                        past: {
                            item: { start: slotData.past_item_id_start, count: past_item_count },
                            location: { start: slotData.past_location_id_start, count: past_location_count },
                        },
                        future: {
                            item: { start: slotData.future_item_id_start, count: future_item_count },
                            location: { start: slotData.future_location_id_start, count: future_location_count },
                        },
                        filler: {
                            item_id: slotData.filler_item_id,
                            location: { start: slotData.filler_location_id_start, count: slotData.filler_location_count },
                        },
                    };
                }

                receiveItems(index, items) {
                    const reset = (index === 0);
                    if (reset) {
                        this.itemIndex = 0;
                    }
                    if (index !== this.itemIndex) {
                        this.socket.send(JSON.stringify([{
                            cmd: "Sync",
                        }]));
                        this.gameStatePast?.resendChecks();
                        this.gameStateFuture?.resendChecks();
                    }
                    this.itemIndex += items.length;
                    const pastItems = [];
                    const futureItems = [];
                    for (const item of items) {
                        const pastIndex = fromRange(item.item, this.idRanges.past.item);
                        if (pastIndex) {
                            pastItems.push({ index: pastIndex.index, locationId: item.location, slotNumber: item.player });
                        }
                        const futureIndex = fromRange(item.item, this.idRanges.future.item);
                        if (futureIndex) {
                            futureItems.push({ index: futureIndex.index, locationId: item.location, slotNumber: item.player });
                        }
                    }
                    this.gameStatePast?.receiveItems(pastItems, reset);
                    this.gameStateFuture?.receiveItems(futureItems, reset);
                }

                scoutLocations(locations) {
                    const pastLocations = [];
                    const futureLocations = [];
                    for (const location in locations) {
                        const pastIndex = fromRange(location.location, this.idRanges.past.location);
                        if (pastIndex) {
                            pastLocations.push({ index: pastIndex.index, itemId: location.item, slotNumber: location.player, flags: location.flags });
                        }
                        const futureIndex = fromRange(location.location, this.idRanges.future.location);
                        if (futureIndex) {
                            futureLocations.push({ index: futureIndex.index, itemId: location.item, slotNumber: location.player, flags: location.flags });
                        }
                    }
                    this.gameStatePast?.scoutLocations(pastLocations);
                    this.gameStateFuture?.scoutLocations(futureLocations);
                }

                addCheckedLocations(locations) {
                    const pastLocations = [];
                    const futureLocations = [];
                    for (const location in locations) {
                        const pastIndex = fromRange(location, this.idRanges.past.location);
                        if (pastIndex) {
                            pastLocations.push(pastIndex.index);
                        }
                        const futureIndex = fromRange(location, this.idRanges.future.location);
                        if (futureIndex) {
                            futureLocations.push(futureIndex.index);
                        }
                    }
                    this.gameStatePast?.addCheckedLocations(pastLocations);
                    this.gameStateFuture?.addCheckedLocations(futureLocations);
                }

                setHints(hints) {
                    // TODO
                }
            }
        };

        class HalfGameState {
            // Map slotNumber to {name, game}
            slotInfo;
            // Array of item index to spoiled location
            spoilers;
            // Map game to { locationIdToName: Map, itemIdToName: Map }
            dataPackages = new Map();
            // Map location index to {slotNumber, itemId, flags}
            scoutedLocations = new Map();
            checkedLocations = new Set();
            // Map item index to {slotNumber, locationId}
            itemFirstFoundLocations = new Map();
            // List of {index, slotNumber, locationIndex}
            receivedItems = [];
            firstReceivedItems = [];
            hints = {
                locations: new Map(),
                items: new Map(),
            };
            callbacks;
            getOtherHalf;

            constructor(slotInfo, spoilers, dataPackages, callbacks, getOtherHalf) {
                this.slotInfo = slotInfo;
                this.spoilers = spoilers;
                this.dataPackages = dataPackages;
                this.callbacks = callbacks;
                this.getOtherHalf = getOtherHalf;
            }

            disconnect() {
                this.callbacks = null;
            }

            receiveItems(items, reset) {
                if (reset) {
                    this.receivedItems = [];
                    this.firstReceivedItems = [];
                    this.itemFirstFoundLocations = new Map();
                }
                for (const item of items) {
                    this.receivedItems.push(item);
                    if (!this.itemFirstFoundLocations.has(item.index)) {
                        this.firstReceivedItems.push(item);
                        this.itemFirstFoundLocations.set(item.index, {
                            slotNumber: item.slotNumber,
                            locationId: item.locationId,
                        });
                    }
                }
                const otherHalf = this.getOtherHalf();
                if (otherHalf?.callbacks) {
                    const locations = Array.from(items.values().map((item) => item.index));
                    otherHalf.callbacks?.check(locations);
                }

                // TODO: signal updated items (maybe all received items, maybe only first received items)
            }

            addCheckedLocations(locations) {
                for (const location of locations) {
                    this.checkedLocations.add(location);
                }
                // TODO: signal checked locations changed
            }

            scoutLocations(locations) {
                for (const location of locations) {
                    this.locations.set(location.index, {
                        slotNumber: location.slotNumber,
                        itemId: location.itemId,
                        flags: location.flags,
                    });
                }
                // TODO: signal scouted locations changed
            }

            setHints(hints) {
                // TODO
            }

            resendChecks() {
                const otherHalf = this.getOtherHalf();
                if (otherHalf) {
                    const locations = Array.from(otherHalf.firstReceivedItems.values().map((item) => item.index));
                    this.callbacks.check(locations);
                }
            }
        }

        // TODO: Goal

        /** Encapsulate the game state between two communicating server halves.
         *
         * Locations of one are items of the other, and vice versa.
         */
        class LogicPair {
            logic = null;
            primaryHalf = null;
            secondaryHalf = null;
            onrepaint;

            constructor(onrepaint) {
                this.onrepaint = onrepaint;
            }

            connectPrimary({
                nonce,
                logic,
                spoilers,
                dataPackages,
                slotInfo,
                callbacks,
            }) {
                console.assert(!this.primaryHalf?.callbacks);
                if (this.logic && !logicEqual(this.logic, { nonce, logic })) {
                    this.secondaryHalf?.callbacks?.evict();
                    this.secondaryHalf = null;
                }
                this.logic = { nonce, logic };
                this.primaryHalf = new HalfGameState(slotInfo, spoilers, dataPackages, callbacks, () => { return this.secondaryHalf; });
                this.onrepaint();
                return this.primaryHalf;
            }

            connectSecondary({
                nonce,
                logic,
                spoilers,
                dataPackages,
                slotInfo,
                callbacks,
            }) {
                console.assert(!this.secondaryHalf?.callbacks);
                if (this.logic) {
                    if (!logicEqual(this.logic, { nonce, logic })) {
                        if (this.primaryHalf?.callbacks) {
                            return null;
                        } else {
                            this.primaryHalf = null;
                            this.logic = { nonce, logic };
                        }
                    }
                } else {
                    this.logic = { nonce, logic };
                }
                this.secondaryHalf = new HalfGameState(slotInfo, spoilers, dataPackages, callbacks, () => { return this.primaryHalf; });
                this.onrepaint();
                return this.secondaryHalf;
            }
        };

        function bindServerInput(rootElement) {
            const addressInput = rootElement.querySelector("input.server-address");
            const slotNameInput = rootElement.querySelector("input.username");
            const passwordInput = rootElement.querySelector("input.password");
            const button = rootElement.querySelector("button");
            const statusWindow = rootElement.querySelector(".connection-info");
            let buttonSaysConnect = true;
            let connect = null;

            button.addEventListener("click", () => {
                connect?.(buttonSaysConnect ?
                    {
                        url: addressInput.value,
                        slotName: slotNameInput.value,
                        password: passwordInput.value,
                    } :
                    null
                );
                updateLocationFragment()
            });

            return {
                onurlchange: (connectionTarget) => {
                    if (connectionTarget) {
                        addressInput.disabled = true;
                        slotNameInput.disabled = true;
                        passwordInput.disabled = true;
                        button.innerText = "Disconnect";
                        buttonSaysConnect = false;
                    } else {
                        addressInput.disabled = false;
                        slotNameInput.disabled = false;
                        passwordInput.disabled = false;
                        button.innerText = "Connect";
                        buttonSaysConnect = true;
                    }
                },
                onstatechange: (kind, description) => {
                    statusWindow.innerText = description;
                },
                setconnect: (listener) => { connect = listener; },
                updatevalues: ({ url, slotName, password }) => {
                    addressInput.value = url ?? '';
                    slotNameInput.value = slotName ?? '';
                    passwordInput.value = password ?? '';
                },
            };
        };

        const pastConnection = new LogicPair(() => {
            // TODO: repaint
        });
        const futureConnection = new LogicPair(() => {
            // TODO: repaint
        });

        const pastCallbacks = bindServerInput(document.getElementById("past-server"));
        const pastSlot = new ServerSlot({
            ...pastCallbacks,
            connectPast: null,
            connectFuture: pastConnection.connectSecondary.bind(pastConnection),
        });
        const presentCallbacks = bindServerInput(document.getElementById("present-server"));
        const presentSlot = new ServerSlot({
            ...presentCallbacks,
            connectPast: pastConnection.connectPrimary.bind(pastConnection),
            connectFuture: futureConnection.connectPrimary.bind(futureConnection),
        });
        const futureCallbacks = bindServerInput(document.getElementById("future-server"));
        const futureSlot = new ServerSlot({
            ...futureCallbacks,
            connectPast: futureConnection.connectSecondary.bind(futureConnection),
            connectFuture: null,
        });


        // Need to encode + & # in fragment after encodeURI()
        function myFragmentEncode(string) {
            const partial = encodeURI(string);
            return partial.replace(/[#&+]/g, encodeURIComponent);
        }

        const slotFragmentParams = [
            [{ url: "s1", slotName: "u1", password: "p1" }, pastCallbacks, pastSlot],
            [{ url: "s2", slotName: "u2", password: "p2" }, presentCallbacks, presentSlot],
            [{ url: "s3", slotName: "u3", password: "p3" }, futureCallbacks, futureSlot],
        ];

        function updateLocationFragment() {
            const activeServers = [];
            for (const [paramNames, _, slot] of slotFragmentParams) {
                if (!slot.connectionTarget) continue;
                const params = [
                    `${paramNames.url}=${myFragmentEncode(slot.connectionTarget.url)}`,
                    `${paramNames.slotName}=${myFragmentEncode(slot.connectionTarget.slotName)}`,
                ];
                if (slot.connectionTarget.password !== "") {
                    params.push(`${paramNames.password}=${myFragmentEncode(slot.connectionTarget.password)}`);
                }
                activeServers.push(params.join("&"));
            }
            history.replaceState(null, "", "#" + activeServers.join("&"));
        }

        function handleHashChange() {
            const params = new URLSearchParams(location.hash.slice(1));
            for (const [paramNames, { updatevalues }, slot] of slotFragmentParams) {
                const settings = {
                    url: params.get(paramNames.url),
                    slotName: params.get(paramNames.slotName),
                    password: params.get(paramNames.password) ?? '',
                };
                updatevalues(settings);
                if (settings.url !== null && settings.slotName !== null) {
                    slot.connect(settings);
                } else {
                    slot.connect(null);
                }
            }
        };

        handleHashChange();

        addEventListener("hashchange", handleHashChange);
    </script>
</body>

</html>
