<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AP DaisyChain Client</title>
    <style>
        /* Generic better CSS defaults, based in large part on https://www.joshwcomeau.com/css/custom-css-reset/ */
        *,
        *:before,
        *:after {
            box-sizing: border-box;
        }

        body {
            line-height: 1.6
        }

        @media (prefers-reduced-motion: no-preference) {
            html {
                interpolate-size: allow-keywords;
            }
        }
    </style>
    <style>
        h1,
        h2,
        h3 {
            margin: 0
        }

        .server {
            border: 1px solid black;
            padding-inline: 0.5em;
            padding-block: 0.2em;
        }

        .server-inputs {
            display: flex;
            flex-flow: row wrap;
            gap: 0em 0.5em;
        }

        .server-address {
            width: 25ch
        }

        .username,
        .password {
            width: 16ch
        }

        .item-table-container {
            display: flex;
            flex-flow: row wrap;
        }

        .item-table-container>div {
            flex: 350px
        }
    </style>
</head>

<body>
    <noscript>This page won't do anything with javascript disabled.</noscript>
    <h1>Archipelago Daisy Chain Proxy Client</h1>
    <!-- TODO: Add link to github repository -->

    <h3>Past:</h3>
    <div class="server" id="past-server">
        <div class="server-inputs">
            <label for="past-address">Server:
                <input type="url" id="past-address" class="server-address"
                    placeholder="wss://archipelago.gg:port" /></label>
            <label for="past-slot">Slot:
                <input type="text" id="past-slot" class="username" placeholder="SlotName" /></label>
            <label for="past-password">Password:
                <input type="password" id="past-password" class="password" placeholder="password" /></label>
        </div>
        <div>
            <button id="past-button">Connect</button>
            <span id="past-status" class="connection-info">Not Connected</span>
        </div>
    </div>
    <h3>Present:</h3>
    <div class="server" id="present-server">
        <div class="server-inputs">
            <label for="present-address">Server:
                <input type="url" id="present-address" class="server-address"
                    placeholder="wss://archipelago.gg:port" /></label>
            <label for="present-slot">Slot:
                <input type="text" id="present-slot" class="username" placeholder="SlotName" /></label>
            <label for="present-password">Password:
                <input type="password" id="present-password" class="password" placeholder="password" /></label>
        </div>
        <div>
            <button id="present-button">Connect</button>
            <span id="present-status" class="connection-info">Not Connected</span>
        </div>
    </div>
    <h3>Future:</h3>
    <div class="server" id="future-server">
        <div class="server-inputs">
            <label for="future-address">Server:
                <input type="url" id="future-address" class="server-address"
                    placeholder="wss://archipelago.gg:port" /></label>
            <label for="future-slot">Slot:
                <input type="text" id="future-slot" class="username" placeholder="SlotName" /></label>
            <label for="future-password">Password:
                <input type="password" id="future-password" class="password" placeholder="password" /></label>
        </div>
        <div>
            <button id="future-button">Connect</button>
            <span id="future-status" class="connection-info">Not Connected</span>
        </div>
    </div>

    <div class="item-table-container">
        <div>
            <h3>Past Connection</h3>
            <div id="past-rows"></div>
        </div>
        <div>
            <h3>Future Connection</h3>
            <div id="future-rows"></div>
        </div>
    </div>

    <script>"use strict";
        /**
         * Takes an array, and performs an in-place random permutation.
         * Copied from https://stackoverflow.com/a/2450976/2644368
        */
        function shuffle(array) {
            let currentIndex = array.length;

            // While there remain elements to shuffle...
            while (currentIndex != 0) {

                // Pick a remaining element...
                let randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;

                // And swap it with the current element.
                [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
            }
        };

        function getOrInsert(map, key, defaultValue) {
            // Map.prototype.getOrInsert is still experimental
            if (map.has(key)) {
                return map.get(key);
            } else {
                map.set(key, defaultValue);
                return defaultValue;
            }
        }

        /**
         * Not currently used by the server, may be used in the future for locking slots.
         * I don't see much problem with reusing it for everyone using this client,
         * but it could also be randomly generated and stored in localStorage in the future.
        */
        const GAME_NAME = "DaisyChain Proxy";
        const CLIENT_UUID = "e42b6a67-536d-43db-a714-96482da24ec2";
        const CLIENT_VERSION = 1;
        const STATUS_GOAL = 30;
        const HINT_UNSPECIFIED = 0;

        const DATA_PACKAGE_STORE_NAME = "DataPackage";

        /** a promise for either null or an IDBDatabase */
        const cacheDb = new Promise((resolve, reject) => {
            const request = indexedDB.open("archipelagoCache");
            request.onerror = () => {
                console.log("Could not open IndexedDB for data package cache");
                resolve(null);
            };
            request.onsuccess = (event) => resolve(event.target.result);
            request.onupgradeneeded = () => {
                const db = event.target.result;
                db.createObjectStore(DATA_PACKAGE_STORE_NAME, { keyPath: ["game", "checksum"] });
            };
        });

        /** Returns undefined if key not found */
        async function getDataPackage({ game, checksum }) {
            const db = await cacheDb;
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(DATA_PACKAGE_STORE_NAME);
                transaction.onabort = () => reject(new Error("transaction failed"));
                const objectStore = transaction.objectStore(DATA_PACKAGE_STORE_NAME);
                const request = objectStore.get([game, checksum]);
                request.onsuccess = (event) => resolve(event.target.result);
            });
        };

        async function putDataPackage(record) {
            const db = await cacheDb;
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(DATA_PACKAGE_STORE_NAME, "readwrite");
                transaction.onabort = (event) => reject(event.target.error);
                const objectStore = transaction.objectStore(DATA_PACKAGE_STORE_NAME);
                const request = objectStore.put(record);
                request.onsuccess = (event) => resolve(event.target.result);
            });
        };

        function sumOfLogic(logic, transpose = false) {
            let items = 0;
            let locations = 0;
            for (const block of logic) {
                items += block.items;
                locations += block.locations.length;
            }
            return transpose ? { items: locations, locations: items } : { items, locations };
        }

        function fromRange(id, { start, count }) {
            const index = id - start;
            if (0 <= index && index < count) {
                return { index };
            } else {
                return null;
            }
        }

        function toRange(index, { start, count }) {
            console.assert(0 <= index && index < count);
            return index + start;
        }

        function logicEqual({ nonce: nonce1, logic: logic1 }, { nonce: nonce2, logic: logic2 }) {
            if (nonce1 !== nonce2) return false;
            if (logic1.length !== logic2.length) return false;
            for (const blockIndex of logic1.keys()) {
                const block1 = logic1[blockIndex];
                const block2 = logic2[blockIndex];
                if (block1.items !== block2.items) return false;
                if (block1.locations.length !== block2.locations.length) return false;
                for (const rowIndex of block1.locations.keys()) {
                    const row1 = new Set(block1.locations[rowIndex]);
                    const row2 = new Set(block2.locations[rowIndex]);
                    if (row1.symmetricDifference(row2).size !== 0) return false;
                }
            }
            return true;
        }

        const ServerStateKind = {
            GOOD: 'good',
            BAD: 'bad',
            NEUTRAL: 'neutral',
        };

        const HAS_PROTOCOL = /^wss?:\/\//;

        /** An object managing a server, such as the Past server slot */
        class ServerSlot {
            // Using public fields is slightly more flexible,
            // and I don't need the encapsulation guarantees of private fields.
            connectionTarget = null;
            liveConnection = null;
            socket = null;
            credentials = null;
            roomInfo = null;
            authenticated = null;
            onurlchange;
            onstatechange;
            connectPast;
            connectFuture;

            constructor({ onurlchange, onstatechange, setconnect, connectPast, connectFuture }) {
                this.onurlchange = onurlchange;
                this.onstatechange = onstatechange;
                setconnect(this.connect.bind(this));
                this.connectPast = connectPast;
                this.connectFuture = connectFuture;
                this.disconnect();
            }

            disconnect() {
                this.liveConnection?.abort()
                this.connectionTarget = null;
                this.onurlchange(null);
                this.onstatechange(ServerStateKind.NEUTRAL, "Disconnected");
            }

            // N.B. This behaves very similar to a setter for this.connectionTarget
            connect(connectionTarget) {
                if (!connectionTarget) {
                    this.disconnect();
                    return;
                }
                const stringURL = connectionTarget.url.toString();
                if (!this.connectionTarget ||
                    this.connectionTarget.url !== stringURL ||
                    this.connectionTarget.slotName !== connectionTarget.slotName ||
                    this.connectionTarget.password !== connectionTarget.password) {
                    // We are changing connectionTarget
                    this.liveConnection?.abort();
                    this.connectionTarget = connectionTarget;
                    this.onurlchange(this.connectionTarget);
                } else if (this.liveConnection) {
                    // Don't need to disconnect and reconnect if we are already connected to the right place.
                    return;
                }
                const candidateURL = URL.parse(HAS_PROTOCOL.test(stringURL) ? stringURL : "wss://" + stringURL);
                if (!candidateURL || candidateURL.hash) {
                    this.onstatechange(ServerStateKind.BAD, "Invalid URL");
                    return;
                }
                this.liveConnection = new AbortController();
                this.liveConnection.signal.addEventListener("abort", () => {
                    this.liveConnection = null;
                    this.socket.close();
                    this.socket = null;
                }, { once: true });
                this.socket = this.#createSocket(candidateURL);
                this.onstatechange(ServerStateKind.NEUTRAL, "Connecting...");
            }

            #createSocket(url) {
                const socket = new WebSocket(url);
                socket.addEventListener("close", this.#closeHandler.bind(this), {
                    once: true,
                    signal: this.liveConnection.signal,
                });
                // We don't actually have anything to do onopen: wait for the server to send RoomInfo.
                socket.addEventListener("message", this.#messageHandler.bind(this), {
                    signal: this.liveConnection.signal,
                });
                return socket;
            }

            #closeHandler() {
                if (this.roomInfo) {
                    // We recieved the RoomInfo packet: this was an anomalous closure
                    this.liveConnection.abort();
                    this.onstatechange(ServerStateKind.BAD, "Connection closed unexpectedly");
                    return;
                }
                let url = new URL(this.socket.url);
                if (url.protocol === "ws:" || HAS_PROTOCOL.test(this.connectionTarget.url)) {
                    this.liveConnection.abort();
                    this.onstatechange(ServerStateKind.BAD, "Unable to connect");
                    return;
                }
                // Fall back to ws from wss
                url.protocol = "ws:";
                this.socket = this.#createSocket(url);
            }

            getNextDataPackage() {
                if (this.roomInfo.gamesToFetch.length === 0) {
                    console.assert(this.roomInfo.games.every((game) => this.roomInfo.dataPackages.has(game)));
                    this.socket.send(JSON.stringify([{
                        cmd: "Connect",
                        name: this.connectionTarget.slotName,
                        game: GAME_NAME,
                        password: this.connectionTarget.password,
                        slot_data: true,
                        items_handling: 0b111 /* All items */,
                        uuid: CLIENT_UUID,
                        tags: ["NoText"],
                        version: { major: 0, minor: 6, build: 5, class: "Version" },
                    }]));
                    this.onstatechange(ServerStateKind.NEUTRAL, "Authenticating...");
                    return;
                }
                const game = this.roomInfo.gamesToFetch.pop();
                console.assert(!this.roomInfo.dataPackages.has(game));
                const requestFromServer = () => {
                    this.socket.send(JSON.stringify([{
                        cmd: "GetDataPackage",
                        games: [game],
                    }]));
                };
                const checksum = this.roomInfo.dataPackageChecksums.get(game);
                if (checksum) {
                    const signal = this.liveConnection.signal;
                    getDataPackage({ game, checksum }).then((result) => {
                        if (signal.aborted) return;
                        if (result) {
                            this.roomInfo.dataPackages.set(game, {
                                locationIdToName: result.locationIdToName,
                                itemIdToName: result.itemIdToName
                            });
                            this.getNextDataPackage();
                        } else {
                            requestFromServer();
                        }
                    }, (error) => {
                        if (signal.aborted) return;
                        this.liveConnection.abort();
                        this.onstatechange(ServerStateKind.BAD, "Error getting data package from cache");
                    });
                } else {
                    requestFromServer();
                }
            }

            #messageHandler(event) {
                // Server could send a binary message, which would turn into a Blob or ArrayBuffer here.
                // Shouldn't happen, ignore for now.
                const handlers = new Map([
                    ["RoomInfo", this.#roomInfoHandler],
                    ["ConnectionRefused", (packet) => {
                        this.liveConnection.abort();
                        this.onstatechange(ServerStateKind.BAD, `Connection refused: ${packet.errors}`);
                    }],
                    ["Connected", this.#connectedPacketHandler],
                    ["ReceivedItems", (packet) => { this.authenticated.receiveItems(packet.index, packet.items); }],
                    ["LocationInfo", (packet) => { this.authenticated.scoutLocations(packet.locations); }],
                    ["RoomUpdate", (packet) => {
                        // Can include permissions, hint_cost, location_check_points, hint_points, players, checked_locations,
                        // of which we only care about checked_locations.
                        if (packet.checked_locations !== undefined) {
                            this.authenticated.addCheckedLocations(packet.checked_locations);
                        }
                    }],
                    ["PrintJSON", (packet) => { /* We are ignoring text messages */ }],
                    ["DataPackage", (packet) => {
                        for (const [game, data] of Object.entries(packet.data.games)) {
                            const itemIdToName = new Map(Object.entries(data.item_name_to_id).map(([name, id]) => [id, name]));
                            const locationIdToName = new Map(Object.entries(data.location_name_to_id).map(([name, id]) => [id, name]));
                            this.roomInfo.dataPackages.set(game, { itemIdToName, locationIdToName });
                            if (data.checksum) {
                                putDataPackage({ game: game, checksum: data.checksum, itemIdToName, locationIdToName });
                            }
                        }
                        this.getNextDataPackage();
                    }],
                    ["Bounced", (packet) => { /* Not expecting any bounces */ }],
                    ["InvalidPacket", (packet) => {
                        console.log(`Server complained of invalid ${packet.cmd} packet (${packet.type}): ${packet.text}`);
                        // Should this abort the connection?
                    }],
                    ["Retrieved", (packet) => {
                        const hints = packet.keys[this.authenticated.hintKey]
                        if (hints !== undefined) {
                            this.authenticated.setHints(hints);
                        }
                    }],
                    ["SetReply", (packet) => {
                        if (packet.key === this.authenticated.hintKey) {
                            this.authenticated.setHints(packet.value);
                        }
                    }],
                ]);
                const defaultHandler = (packet) => {
                    console.log(`Unrecognized packet type ${packet.cmd}`);
                };
                const packets = JSON.parse(event.data);
                const signal = this.liveConnection.signal;
                for (const packet of packets) {
                    (handlers.get(packet.cmd) || defaultHandler).call(this, packet);
                    if (signal.aborted) return;
                }
            }

            #roomInfoHandler(packet) {
                if (this.roomInfo) {
                    this.liveConnection.abort();
                    this.onstatechange(ServerStateKind.BAD, "Protocol violation: double RoomInfo packet");
                    return;
                }
                shuffle(packet.games);
                this.roomInfo = {
                    games: packet.games,
                    gamesToFetch: packet.games,
                    dataPackages: new Map(),
                    dataPackageChecksums: new Map(Object.entries(packet.datapackage_checksums))
                }
                this.liveConnection.signal.addEventListener("abort",
                    () => { this.roomInfo = null },
                    { once: true },
                );
                this.getNextDataPackage();
                this.onstatechange(ServerStateKind.NEUTRAL, "Downloading data packages...");
            }

            #connectedPacketHandler(packet) {
                if (this.authenticated) {
                    this.liveConnection.abort();
                    this.onstatechange(ServerStateKind.BAD, "Protocol violation: double connected packet");
                    return;
                }
                const slotData = packet.slot_data;
                if (slotData.version > CLIENT_VERSION) {
                    this.liveConnection.abort();
                    this.onstatechange(ServerStateKind.BAD, `Must update client to version ${slotData.version}`);
                    return;
                }
                const slotInfo = new Map(Object.entries(packet.slot_info).map(([k, v]) => [Number(k), v]));
                const evict = () => {
                    this.liveConnection.abort();
                    this.onstatechange(ServerStateKind.BAD, "Logic mismatch");
                };
                const needPastForGoal = slotData.past_logic.length !== 0;
                const needFutureForGoal = slotData.future_logic.length !== 0;
                const checkGoal = () => {
                    if ((!needPastForGoal || this.authenticated?.gameStatePast?.isGoal()) &&
                        (!needFutureForGoal || this.authenticated?.gameStateFuture?.isGoal())) {
                        this.socket.send(JSON.stringify([
                            { cmd: "StatusUpdate", status: STATUS_GOAL },
                        ]));
                    }
                };
                const updateHint = ({ player, location, status }) => {
                    this.socket.send(JSON.stringify([
                        { cmd: "UpdateHint", player, location, status },
                    ]))
                };
                const createItemHint = ({ player, location }, status) => {
                    this.socket.send(JSON.stringify([
                        { cmd: "CreateHints", player, locations: [location], status },
                    ]));
                };
                let gameStatePast = null;
                if (this.connectPast) {
                    gameStatePast = this.connectPast({
                        nonce: slotData.past_nonce,
                        logic: slotData.past_logic,
                        spoilers: slotData.past_item_spoilers,
                        dataPackages: this.roomInfo.dataPackages,
                        slotInfo: slotInfo,
                        callbacks: {
                            evict,
                            check: (locationIndexes) => {
                                const locationIds = Array.from(locationIndexes.values().map((index) =>
                                    toRange(index, this.authenticated.idRanges.past.location)
                                ));
                                this.socket.send(JSON.stringify([
                                    { cmd: "LocationScouts", locations: locationIds, create_as_hint: 0 },
                                    { cmd: "LocationChecks", locations: locationIds },
                                ]));
                            },
                            sendFiller: () => { },
                            checkGoal,
                            updateHint,
                            createItemHint,
                            createLocationHints: (locationIndexes) => {
                                const locationIds = Array.from(locationIndexes.values().map((index) =>
                                    toRange(index, this.authenticated.idRanges.past.location)
                                ));
                                this.socket.send(JSON.stringify([
                                    { cmd: "LocationScouts", locations: locationIds, create_as_hint: 2 },
                                ]));
                            },
                        },
                    });
                    if (!gameStatePast) {
                        this.liveConnection.abort();
                        this.onstatechange(ServerStateKind.BAD, "Logic mismatch");
                        return;
                    }
                    this.liveConnection.signal.addEventListener("abort",
                        gameStatePast.disconnect.bind(gameStatePast),
                        { once: true },
                    );
                }
                let gameStateFuture = null;
                if (this.connectFuture) {
                    gameStateFuture = this.connectFuture({
                        nonce: slotData.nonce,
                        logic: slotData.future_logic,
                        spoilers: slotData.future_item_spoilers,
                        dataPackages: this.roomInfo.dataPackages,
                        slotInfo: slotInfo,
                        callbacks: {
                            evict,
                            check: (locations) => {
                                const locationIds = Array.from(locations.values().map((index) =>
                                    toRange(index, this.authenticated.idRanges.future.location)
                                ));
                                this.socket.send(JSON.stringify([
                                    { cmd: "LocationScouts", locations: locationIds, create_as_hint: 0 },
                                    { cmd: "LocationChecks", locations: locationIds },
                                ]));
                            },
                            sendFiller: () => {
                                const locationIds = [];
                                for (let i = 0; i < this.authenticated.idRanges.filler.location.count; i++) {
                                    locationIds.push(this.authenticated.idRanges.filler.location.start + i);
                                }
                                this.socket.send(JSON.stringify([
                                    { cmd: "LocationChecks", locations: locationIds },
                                ]));
                            },
                            checkGoal,
                            updateHint,
                            createItemHint,
                            createLocationHints: (locationIndexes) => {
                                const locationIds = Array.from(locationIndexes.values().map((index) =>
                                    toRange(index, this.authenticated.idRanges.future.location)
                                ));
                                this.socket.send(JSON.stringify([
                                    { cmd: "LocationScouts", locations: locationIds, create_as_hint: 2 },
                                ]))
                            },
                        },
                    });
                    if (!gameStateFuture) {
                        this.liveConnection.abort();
                        this.onstatechange(ServerStateKind.BAD, "Logic mismatch");
                        return;
                    }
                    this.liveConnection.signal.addEventListener("abort",
                        gameStateFuture.disconnect.bind(gameStateFuture),
                        { once: true },
                    );
                }
                this.authenticated = new ServerSlot.#AuthBlock(packet.team, packet.slot, slotData, gameStatePast, gameStateFuture);
                this.authenticated.gameStatePast?.resendChecks();
                this.authenticated.gameStateFuture?.resendChecks();
                this.socket.send(JSON.stringify([
                    { cmd: "SetNotify", keys: [this.authenticated.hintKey] },
                    { cmd: "Get", keys: [this.authenticated.hintKey] },
                ]));
                this.authenticated.gameStatePast?.resendHints();
                this.authenticated.gameStateFuture?.resendHints();
                checkGoal();
                this.liveConnection.signal.addEventListener("abort",
                    () => { this.authenticated = null; },
                    { once: true },
                );
                this.authenticated.addCheckedLocations(packet.checked_locations);
                this.onstatechange(ServerStateKind.GOOD, "Connected");
            }

            static #AuthBlock = class {
                teamNumber;
                slotNumber;
                hintKey;
                itemIndex = 0;
                gameStatePast;
                gameStateFuture;
                idRanges;

                constructor(teamNumber, slotNumber, slotData, gameStatePast, gameStateFuture) {
                    this.teamNumber = teamNumber;
                    this.slotNumber = slotNumber;
                    this.hintKey = `_read_hints_${teamNumber}_${slotNumber}`;
                    this.gameStatePast = gameStatePast;
                    this.gameStateFuture = gameStateFuture;
                    // Because past logic gives the transpose matrix, swap items and locations.
                    const { items: past_location_count, locations: past_item_count } = sumOfLogic(slotData.past_logic);
                    const { items: future_item_count, locations: future_location_count } = sumOfLogic(slotData.future_logic);
                    this.idRanges = {
                        past: {
                            item: { start: slotData.past_item_id_start, count: past_item_count },
                            location: { start: slotData.past_location_id_start, count: past_location_count },
                        },
                        future: {
                            item: { start: slotData.future_item_id_start, count: future_item_count },
                            location: { start: slotData.future_location_id_start, count: future_location_count },
                        },
                        filler: {
                            item_id: slotData.filler_item_id,
                            location: { start: slotData.filler_location_id_start, count: slotData.filler_location_count },
                        },
                    };
                }

                receiveItems(index, items) {
                    const reset = (index === 0);
                    if (reset) {
                        this.itemIndex = 0;
                    }
                    if (index !== this.itemIndex) {
                        this.socket.send(JSON.stringify([{ cmd: "Sync", }]));
                        this.gameStatePast?.resendChecks();
                        this.gameStateFuture?.resendChecks();
                    }
                    this.itemIndex += items.length;
                    for (const [idRange, gameState] of [
                        [this.idRanges.past, this.gameStatePast],
                        [this.idRanges.future, this.gameStateFuture]
                    ]) {
                        if (!gameState) continue;
                        const filteredItems = [];
                        for (const item of items) {
                            const index = fromRange(item.item, idRange.item);
                            if (index) {
                                filteredItems.push({
                                    index: index.index,
                                    locationId: item.location,
                                    slotNumber: item.player,
                                });
                            }
                        }
                        gameState.receiveItems(filteredItems, reset);
                    }
                }

                scoutLocations(locations) {
                    for (const [idRange, gameState] of [
                        [this.idRanges.past, this.gameStatePast],
                        [this.idRanges.future, this.gameStateFuture]
                    ]) {
                        if (!gameState) continue;
                        const filteredLocations = [];
                        for (const location of locations) {
                            const index = fromRange(location.location, idRange.location);
                            if (index) {
                                filteredLocations.push({
                                    index: index.index,
                                    itemId: location.item,
                                    slotNumber: location.player,
                                    flags: location.flags,
                                });
                            }
                        }
                        gameState.scoutLocations(filteredLocations);
                    }
                }

                addCheckedLocations(locations) {
                    for (const [idRange, gameState] of [
                        [this.idRanges.past, this.gameStatePast],
                        [this.idRanges.future, this.gameStateFuture]
                    ]) {
                        if (!gameState) continue;
                        const filteredLocations = [];
                        for (const location of locations) {
                            const index = fromRange(location, idRange.location);
                            if (index) {
                                filteredLocations.push(index.index);
                            }
                        }
                        gameState.addCheckedLocations(filteredLocations);
                    }
                }

                setHints(hints) {
                    for (const [idRange, gameState] of [
                        [this.idRanges.past, this.gameStatePast],
                        [this.idRanges.future, this.gameStateFuture]
                    ]) {
                        if (!gameState) continue;
                        const filteredLocationHints = new Map();
                        const filteredItemHints = new Map();
                        for (const hint of hints) {
                            if (hint.found) continue;
                            if (hint.finding_player === this.slotNumber) {
                                const index = fromRange(hint.location, idRange.location);
                                if (index) {
                                    filteredLocationHints.set(index.index, hint);
                                }
                            }
                            if (hint.receiving_player === this.slotNumber) {
                                const index = fromRange(hint.item, idRange.item);
                                if (index) {
                                    getOrInsert(filteredItemHints, index.index, []).push(hint);
                                }
                            }
                        }
                        gameState.setHints(filteredLocationHints, filteredItemHints);
                    }
                }
            }
        };

        class HalfGameState {
            // Map slotNumber to {name, game}
            slotInfo;
            // Array of item index to spoiled location
            spoilers;
            // Map game to { locationIdToName: Map, itemIdToName: Map }
            dataPackages = new Map();
            // Map location index to {slotNumber, itemId, flags}
            scoutedLocations = new Map();
            checkedLocations = new Set();
            // Map item index to {slotNumber, locationId}
            itemFirstFoundLocations = new Map();
            // List of {index, slotNumber, locationIndex}
            receivedItems = [];
            firstReceivedItems = [];
            hints = {
                locations: new Map(),
                items: new Map(),
            };
            callbacks;
            getOtherHalf;
            uiCallbacks;
            totals;

            constructor(totals, slotInfo, spoilers, dataPackages, callbacks, getOtherHalf, uiCallbacks) {
                this.totals = totals;
                this.slotInfo = slotInfo;
                this.spoilers = spoilers;
                this.dataPackages = dataPackages;
                this.callbacks = callbacks;
                this.getOtherHalf = getOtherHalf;
                this.uiCallbacks = uiCallbacks;
            }

            disconnect() {
                this.callbacks = null;
            }

            receiveItems(items, reset) {
                if (reset) {
                    this.receivedItems = [];
                    this.firstReceivedItems = [];
                    this.itemFirstFoundLocations = new Map();
                }
                for (const item of items) {
                    console.assert(0 <= item.index && item.index < this.totals.items && Number.isInteger(item.index));
                    this.receivedItems.push(item);
                    if (!this.itemFirstFoundLocations.has(item.index)) {
                        this.firstReceivedItems.push(item);
                        this.itemFirstFoundLocations.set(item.index, {
                            slotNumber: item.slotNumber,
                            locationId: item.locationId,
                        });
                    }
                }
                this.callbacks.checkGoal();

                const otherHalf = this.getOtherHalf();
                if (otherHalf?.callbacks) {
                    const locations = Array.from(items.values().map((item) => item.index));
                    otherHalf.callbacks.check(locations);
                    otherHalf.callbacks.checkGoal();
                }

                this.uiCallbacks.repaint();
            }

            addCheckedLocations(locations) {
                for (const location of locations) {
                    console.assert(0 <= location && location < this.totals.locations && Number.isInteger(location));
                    this.checkedLocations.add(location);
                }
                // Not tracking checked locations in ui
            }

            scoutLocations(locations) {
                for (const location of locations) {
                    console.assert(0 <= location.index && location.index < this.totals.locations && Number.isInteger(location.index));
                    this.scoutedLocations.set(location.index, {
                        slotNumber: location.slotNumber,
                        itemId: location.itemId,
                        flags: location.flags,
                    });
                }
                this.uiCallbacks.repaint();
            }

            setHints(locationHints, itemHints) {
                this.hints = { locations: locationHints, items: itemHints };
                this.getOtherHalf()?.resendHints();
                this.resendHints();
                for (const [index, { receiving_player: player, item, item_flags: flags }] of this.hints.locations.entries()) {
                    if (!this.scoutedLocations.has(index)) {
                        this.scoutedLocations.set(index, { slotNumber: player, itemId: item, flags });
                    }
                }
                this.uiCallbacks.repaint();
            }

            resendHints() {
                if (!this.callbacks) return;
                const otherHalf = this.getOtherHalf();
                if (!otherHalf) return;
                for (const [index, primaryHint] of otherHalf.hints.locations.entries()) {
                    const status = primaryHint.status;
                    const spoiler = this.spoilers[index];
                    let spoilerHinted = false;
                    const secondaryHints = getOrInsert(this.hints.items, index, [])
                    for (const hint of secondaryHints) {
                        if (hint.status !== status) {
                            this.callbacks.updateHint({ player: hint.finding_player, location: hint.location, status: status });
                            hint.status = status;
                        }
                        if (hint.finding_player === spoiler.player && hint.location === spoiler.location) spoilerHinted = true;
                    }
                    if (!spoilerHinted) {
                        this.callbacks.createItemHint(spoiler, status);
                        secondaryHints.push({ finding_player: spoiler.player, location: spoiler.location, status: status });
                    }
                }
                const newLocationsToHint = [];
                for (const [index, otherHints] of otherHalf.hints.items.entries()) {
                    if (!this.hints.locations.has(index)) {
                        newLocationsToHint.push(index);
                        this.hints.locations.set(index, { status: HINT_UNSPECIFIED });
                        for (const hint of otherHints) {
                            otherHints.status = HINT_UNSPECIFIED;
                        }
                    }
                }
                this.callbacks.createLocationHints(newLocationsToHint);
                this.uiCallbacks.repaint();
            }

            resendChecks() {
                this.callbacks.sendFiller();
                const otherHalf = this.getOtherHalf();
                if (otherHalf) {
                    const locations = Array.from(otherHalf.firstReceivedItems.values().map((item) => item.index));
                    this.callbacks.check(locations);
                }
            }

            isGoal() {
                return (
                    this.itemFirstFoundLocations.size === this.totals.items &&
                    (this.totals.locations === 0 || this.getOtherHalf()?.itemFirstFoundLocations.size === this.totals.locations));
            }
        }

        /** Encapsulate the game state between two communicating server halves.
         *
         * Locations of one are items of the other, and vice versa.
         */
        class LogicPair {
            logic = null;
            primaryHalf = null;
            secondaryHalf = null;
            uiCallbacks;
            transposeLogic;

            constructor(uiCallbacks, transposeLogic) {
                this.uiCallbacks = uiCallbacks;
                this.transposeLogic = transposeLogic;
            }

            connectPrimary({
                nonce,
                logic,
                spoilers,
                dataPackages,
                slotInfo,
                callbacks,
            }) {
                console.assert(!this.primaryHalf?.callbacks);
                if (this.logic && !logicEqual(this.logic, { nonce, logic })) {
                    this.secondaryHalf?.callbacks?.evict();
                    this.secondaryHalf = null;
                }
                this.logic = { nonce, logic };
                this.primaryHalf = new HalfGameState(
                    sumOfLogic(this.logic.logic),
                    slotInfo, spoilers, dataPackages, callbacks, () => { return this.secondaryHalf; },
                    {
                        updateItem: (index) => this.uiCallbacks.updatePrimaryItem(this, index),
                        updateLocation: (index) => this.uiCallbacks.updatePrimaryLocation(this, index),
                        repaint: () => this.uiCallbacks.repaint(this),
                    },
                );
                this.uiCallbacks.repaint(this);
                return this.primaryHalf;
            }

            connectSecondary({
                nonce,
                logic,
                spoilers,
                dataPackages,
                slotInfo,
                callbacks,
            }) {
                console.assert(!this.secondaryHalf?.callbacks);
                if (this.logic) {
                    if (!logicEqual(this.logic, { nonce, logic })) {
                        if (this.primaryHalf?.callbacks) {
                            return null;
                        } else {
                            this.primaryHalf = null;
                            this.logic = { nonce, logic };
                        }
                    }
                } else {
                    this.logic = { nonce, logic };
                }
                this.secondaryHalf = new HalfGameState(
                    sumOfLogic(this.logic.logic, true),
                    slotInfo, spoilers, dataPackages, callbacks, () => { return this.primaryHalf; },
                    {
                        updateItem: (index) => this.uiCallbacks.updatePrimaryLocation(this, index),
                        updateLocation: (index) => this.uiCallbacks.updatePrimaryItem(this, index),
                        repaint: () => this.uiCallbacks.repaint(this),
                    },
                );
                this.uiCallbacks.repaint(this);
                return this.secondaryHalf;
            }
        };

        function bindServerInput(rootElement) {
            const addressInput = rootElement.querySelector("input.server-address");
            const slotNameInput = rootElement.querySelector("input.username");
            const passwordInput = rootElement.querySelector("input.password");
            const button = rootElement.querySelector("button");
            const statusWindow = rootElement.querySelector(".connection-info");
            let buttonSaysConnect = true;
            let connect = null;

            button.addEventListener("click", () => {
                connect?.(buttonSaysConnect ?
                    {
                        url: addressInput.value,
                        slotName: slotNameInput.value,
                        password: passwordInput.value,
                    } :
                    null
                );
                updateLocationFragment()
            });

            return {
                onurlchange: (connectionTarget) => {
                    if (connectionTarget) {
                        addressInput.disabled = true;
                        slotNameInput.disabled = true;
                        passwordInput.disabled = true;
                        button.innerText = "Disconnect";
                        buttonSaysConnect = false;
                    } else {
                        addressInput.disabled = false;
                        slotNameInput.disabled = false;
                        passwordInput.disabled = false;
                        button.innerText = "Connect";
                        buttonSaysConnect = true;
                    }
                },
                onstatechange: (kind, description) => {
                    statusWindow.innerText = description;
                },
                setconnect: (listener) => { connect = listener; },
                updatevalues: ({ url, slotName, password }) => {
                    addressInput.value = url ?? '';
                    slotNameInput.value = slotName ?? '';
                    passwordInput.value = password ?? '';
                },
            };
        };

        function makeItemSpan(name) {
            const span = document.createElement("span");
            span.replaceChildren([name]);
            span.classList.add("item");
            return span;
        };

        function makeLocationSpan(name) {
            const span = document.createElement("span");
            span.replaceChildren([name]);
            span.classList.add("location");
            return span;
        };

        function makePlayerSpan(name) {
            const span = document.createElement("span");
            span.replaceChildren(name);
            span.classList.add("player");
            return span;
        };

        function makeAttributedItemSpan(gameState, { slotNumber, id, qualifier = null }) {
            const span = document.createElement("span");
            const { name: playerName, game } = gameState.slotInfo.get(slotNumber);
            const itemName = gameState.dataPackages.get(game).itemIdToName.get(id);
            span.replaceChildren(makePlayerSpan(playerName), "'s ", makeItemSpan(itemName));
            if (qualifier) span.prepend(qualifier, " ");
            span.classList.add("player-item");
            return span;
        };

        function makeAttributedLocationSpan(gameState, { slotNumber, id, qualifier = null }) {
            const span = document.createElement("span");
            const { name: playerName, game } = gameState.slotInfo.get(slotNumber);
            const locationName = gameState.dataPackages.get(game).locationIdToName.get(id);
            span.replaceChildren(makePlayerSpan(playerName), "'s ", makeLocationSpan(locationName));
            if (qualifier) span.prepend(qualifier, " ");
            span.classList.add("player-location");
            return span;
        };

        function indexToString(index) {
            return "#" + String(index + 1).padStart(3, "0");
        }

        function daisyChainName({ isItem, isPast, index }) {
            return `${isItem ? "Item for" : "Location in"} ${isPast ? "Past" : "Future"} ${indexToString(index)}`;
        }

        function daisyChainSpan({ isPast, isItem, index }) {
            return (isItem ? makeItemSpan : makeLocationSpan)(daisyChainName({ isPast, isItem, index }));
        }

        function makeFullSpan({ gameState, indexIsItem, index, qualifier = null }) {
            if (!gameState) return null;
            if (indexIsItem) {
                let location = gameState.itemFirstFoundLocations.get(index);
                const found = Boolean(location);
                if (!found && gameState.hints.items.has(index)) {
                    const spoiler = gameState.spoilers[index];
                    location = { slotNumber: spoiler.player, locationId: spoiler.location };
                }
                if (!location) return null;
                return {
                    found,
                    span: makeAttributedLocationSpan(gameState, {
                        slotNumber: location.slotNumber,
                        id: location.locationId,
                        qualifier,
                    })
                };
            } else {
                const item = gameState.scoutedLocations.get(index);
                if (!item) return null;
                return makeAttributedItemSpan(gameState, {
                    slotNumber: item.slotNumber,
                    id: item.itemId,
                    qualifier,
                });
            }
        }

        function bindConnectionOutput(rootElement, logicTranspose, qualifier) {
            const container = rootElement;
            let itemRows = [];
            let locationRows = [];

            const makeItemRow = (logicPair, index) => {
                const row = document.createElement("div");
                const locationSpan = makeFullSpan({ gameState: logicPair.primaryHalf, indexIsItem: true, index });
                const itemSpan = makeFullSpan({ gameState: logicPair.secondaryHalf, indexIsItem: false, index, qualifier });
                const defaultItemSpan = daisyChainSpan({ isItem: true, isPast: logicTranspose, index });
                if (locationSpan) {
                    row.replaceChildren(
                        indexToString(index), ": ",
                        locationSpan.span,
                        locationSpan.found ? " contained " : " contains ",
                        itemSpan ?? defaultItemSpan,
                    );
                    if (!locationSpan.found) row.prepend("Hint ");
                } else {
                    if (itemSpan) {
                        row.replaceChildren(
                            defaultItemSpan, " is ",
                            itemSpan,
                        );
                    } else {
                        row.replaceChildren(
                            defaultItemSpan,
                            " not found yet",
                        );
                    }
                }
                return row;
            };
            const makeLocationRow = (logicPair, index) => {
                const row = document.createElement("div");
                const itemSpan = makeFullSpan({ gameState: logicPair.primaryHalf, indexIsItem: false, index });
                const locationSpan = makeFullSpan({ gameState: logicPair.secondaryHalf, indexIsItem: true, index, qualifier });
                const defaultLocationSpan = daisyChainSpan({ isPast: logicTranspose, isItem: false, index });
                if (itemSpan) {
                    row.replaceChildren(
                        indexToString(index), ": ",
                        itemSpan,
                        " is in ",
                        locationSpan?.span ?? defaultLocationSpan,
                    );
                    if (locationSpan && !locationSpan.found) row.prepend("Hint ");
                } else {
                    if (locationSpan) {
                        row.replaceChildren(
                            defaultLocationSpan,
                            " is ",
                            locationSpan.span,
                        )
                    } else {
                        row.replaceChildren(
                            defaultLocationSpan,
                            " has not been checked"
                        );
                    }
                }
                return row;
            };

            return {
                repaint: (logicPair) => {
                    const { items: itemCount, locations: locationCount } = sumOfLogic(logicPair.logic.logic, logicTranspose);
                    itemRows = [];
                    locationRows = [];
                    for (let i = 0; i < itemCount; i++) {
                        itemRows.push(makeItemRow(logicPair, i));
                    }
                    for (let i = 0; i < locationCount; i++) {
                        locationRows.push(makeLocationRow(logicPair, i));
                    }
                    rootElement.replaceChildren(...itemRows, ...locationRows);
                },
                updatePrimaryItem: (logicPair, index) => {
                    console.assert(0 <= index && index <= itemRows.length && Number.isInteger(index));
                    let row = itemRows[index];
                    if (!row) return;
                    row.replaceWith(makeItemRow(logicPair, index));
                },
                updatePrimaryLocation: (logicPair, index) => {
                    console.assert(0 <= index && index <= itemRows.length && Number.isInteger(index));
                    let row = locationRows[index];
                    if (!row) return;
                    row.replaceWith(makeLocationRow(logicPair, index));
                },
            }
        };

        const pastConnectionUI = bindConnectionOutput(document.getElementById("past-rows"), true, "Past");
        const futureConnectionUI = bindConnectionOutput(document.getElementById("future-rows"), false, "Future");

        const pastConnection = new LogicPair(pastConnectionUI);
        const futureConnection = new LogicPair(futureConnectionUI);

        const pastCallbacks = bindServerInput(document.getElementById("past-server"));
        const pastSlot = new ServerSlot({
            ...pastCallbacks,
            connectPast: null,
            connectFuture: pastConnection.connectSecondary.bind(pastConnection),
        });
        const presentCallbacks = bindServerInput(document.getElementById("present-server"));
        const presentSlot = new ServerSlot({
            ...presentCallbacks,
            connectPast: pastConnection.connectPrimary.bind(pastConnection),
            connectFuture: futureConnection.connectPrimary.bind(futureConnection),
        });
        const futureCallbacks = bindServerInput(document.getElementById("future-server"));
        const futureSlot = new ServerSlot({
            ...futureCallbacks,
            connectPast: futureConnection.connectSecondary.bind(futureConnection),
            connectFuture: null,
        });

        // Need to encode + & # in fragment after encodeURI()
        function myFragmentEncode(string) {
            const partial = encodeURI(string);
            return partial.replace(/[#&+]/g, encodeURIComponent);
        }

        const slotFragmentParams = [
            [{ url: "s1", slotName: "u1", password: "p1" }, pastCallbacks, pastSlot],
            [{ url: "s2", slotName: "u2", password: "p2" }, presentCallbacks, presentSlot],
            [{ url: "s3", slotName: "u3", password: "p3" }, futureCallbacks, futureSlot],
        ];

        function updateLocationFragment() {
            const activeServers = [];
            for (const [paramNames, _, slot] of slotFragmentParams) {
                if (!slot.connectionTarget) continue;
                const params = [
                    `${paramNames.url}=${myFragmentEncode(slot.connectionTarget.url)}`,
                    `${paramNames.slotName}=${myFragmentEncode(slot.connectionTarget.slotName)}`,
                ];
                if (slot.connectionTarget.password !== "") {
                    params.push(`${paramNames.password}=${myFragmentEncode(slot.connectionTarget.password)}`);
                }
                activeServers.push(params.join("&"));
            }
            history.replaceState(null, "", "#" + activeServers.join("&"));
        }

        function handleHashChange() {
            const params = new URLSearchParams(location.hash.slice(1));
            for (const [paramNames, { updatevalues }, slot] of slotFragmentParams) {
                const settings = {
                    url: params.get(paramNames.url),
                    slotName: params.get(paramNames.slotName),
                    password: params.get(paramNames.password) ?? '',
                };
                updatevalues(settings);
                if (settings.url !== null && settings.slotName !== null) {
                    slot.connect(settings);
                } else {
                    slot.connect(null);
                }
            }
        };

        handleHashChange();

        addEventListener("hashchange", handleHashChange);
    </script>
</body>

</html>
