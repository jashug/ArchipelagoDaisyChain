<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AP DaisyChain Client</title>
    <link rel="modulepreload" href="https://unpkg.com/archipelago.js@2.0.4/dist/archipelago.min.js" />
    <style>
        /* Generic better CSS defaults, based in large part on https://www.joshwcomeau.com/css/custom-css-reset/ */
        *,
        *:before,
        *:after {
            box-sizing: border-box;
        }

        body {
            line-height: 1.6
        }

        @media (prefers-reduced-motion: no-preference) {
            html {
                interpolate-size: allow-keywords;
            }
        }
    </style>
    <style>
        h1,
        h2 {
            margin: 0
        }

        :target {
            border: 2px solid black;
        }

        .server>input[type="url"] {
            width: 55ch
        }
    </style>
</head>

<body>
    <noscript>This page won't do anything with javascript disabled.</noscript>
    <h1>Archipelago Daisy Chain Proxy Client</h1>
    <!-- TODO: Add link to github repository -->

    <h2>Server Connections</h2>
    <div class="server">
        <label for="past-server">Past: </label>
        <input type="url" id="past-server" placeholder="SlotName:password@archipelago.gg:port" />
        <button>Connect</button>
        <span class="connection-info">Not Connected</span>
    </div>
    <div class="server">
        <label for="present-server">Present: </label>
        <input type="url" id="present-server" placeholder="SlotName:password@archipelago.gg:port" />
        <button>Connect</button>
        <span class="connection-info">Not Connected</span>
    </div>
    <div class="server">
        <label for="future-server">Future: </label>
        <input type="url" id="future-server" placeholder="SlotName:password@archipelago.gg:port" />
        <button>Connect</button>
        <span class="connection-info">Not Connected</span>
    </div>

    <div class="to-be-targeted">Hello</div>

    <script type="module">
        import { } from "https://unpkg.com/archipelago.js@2.0.4/dist/archipelago.min.js";
    </script>

    <script>"use strict";
        let Archipelago;

        import("https://unpkg.com/archipelago.js@2.0.4/dist/archipelago.min.js").then((module) => {
            Archipelago = module;
        });

        window.addEventListener("hashchange", (event) => {
            console.log(`hash changed: ${event.newURL}`);
            let newURL = new URL(event.newURL);
            let target_div = document.querySelector("body div.to-be-targeted");
            target_div.id = new URL(event.newURL).hash
        });

        /**
         * Takes an array, and performs an in-place random permutation.
         * Copied from https://stackoverflow.com/a/2450976/2644368
        */
        function shuffle(array) {
            let currentIndex = array.length;

            // While there remain elements to shuffle...
            while (currentIndex != 0) {

                // Pick a remaining element...
                let randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;

                // And swap it with the current element.
                [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
            }
        };

        /*
        We have three server slots: Past, Present, and Future.
        The operation of each is very similar.

        A server can be in one of five states:
        - Disconnected
        - Connecting (socket created)
        - Waiting for RoomInfo (socket open event recieved)
        - Authenticating (RoomInfo message recieved, Connect message sent)
        - Connected (Connected message recieved)

        Most of the rest of the world doesn't care about the difference between Connecting, Waiting for RoomInfo, and Authenticating,
        with all three states indicating a live WebSocket that can not yet be sent checks/hints,
        and may not have matching nonce/logic (and thus be rejected).
        In these states, the server will also not be sending items and locations.

        We want the ability to, from the outside, call a close method on the server to reset it to
        Disconnected immediately, and prevent recieving further items/locations/hints.

        Local data is very similar on the two links past-present and present-future.
        Each pair maintains a shared nonce/logic, and can have each half connected or disconnected.

        The nonce/logic is updated (and cached data cleared) if the nonce/logic doesn't match and
        the other side is disconnected or this side has priority (in which case call a stored close on the other side).
        While a connection is established, the logic won't change until close is called.
        Each side can report an item recieved, a locationscout, a hint (split into hint item and hint location?).

        When the location.hash changes: decode the hash to determine server addresses.
        Disconnect servers which are not present in the new hash, or which are different from the current
        values for servers not disconnected. Then connect servers which are disconnected that should be connected.

        Pressing a connect/disconnect button changes the hash, using the other two parts directly.

        From the main logic's perspective, each server is either connected or not.
        The only part of the system that wants to know about in-progress connections is the logic to disconnect
        from a server by onhashchange, and this can be encapsulated in the full close method.
        */

        /**
         * Not currently used by the server, may be used in the future for locking slots.
         * I don't see much problem with reusing it for everyone using this client,
         * but it could also be randomly generated and stored in localStorage in the future.
        */
        const GAME_NAME = "DaisyChain Proxy";
        const CLIENT_UUID = "e42b6a67-536d-43db-a714-96482da24ec2";

        const DATA_PACKAGE_STORE_NAME = "DataPackage";

        /** a promise for either null or an IDBDatabase */
        const cacheDb = new Promise((resolve, reject) => {
            const request = indexedDB.open("archipelagoCache");
            request.onerror = () => {
                console.log("Could not open IndexedDB for data package cache");
                resolve(null);
            };
            request.onsuccess = (event) => resolve(event.target.result);
            request.onupgradeneeded = () => {
                const db = event.target.result;
                db.createObjectStore(DATA_PACKAGE_STORE_NAME, { keyPath: ["game", "checksum"] });
            };
        });

        /** Returns undefined if key not found */
        async function getDataPackage(key) {
            const db = await cacheDb;
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(DATA_PACKAGE_STORE_NAME);
                transaction.onabort = () => reject(new Error("transaction failed"));
                const objectStore = transaction.objectStore(DATA_PACKAGE_STORE_NAME);
                const request = objectStore.get(key);
                request.onsuccess = (event) => resolve(event.target.result);
            });
        };

        async function putDataPackage(record) {
            const db = await cacheDb;
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(DATA_PACKAGE_STORE_NAME, "readwrite");
                transaction.onabort = (event) => reject(event.target.error);
                const objectStore = transaction.objectStore(DATA_PACKAGE_STORE_NAME);
                const request = objectStore.put(record);
                request.onsuccess = (event) => resolve(event.target.result);
            });
        };

        const ServerStateKind = {
            GOOD: 'good',
            BAD: 'bad',
            NEUTRAL: 'neutral',
        }

        const HAS_PROTOCOL = /^wss?:\/\//;

        /** An object managing a server, such as the Past server slot */
        class ServerSlot {
            // Using public fields is slightly more flexible,
            // and I don't need the encapsulation guarantees of private fields.
            stringURL = null;
            liveConnection = null;
            socket = null;
            credentials = null;
            datapackageChecksums = null;
            idRanges = null;
            onurlchange;
            onstatechange;

            constructor({ onurlchange, onstatechange }) {
                this.onurlchange = onurlchange;
                this.onstatechange = onstatechange;
            }

            disconnect() {
                this.liveConnection?.abort()
                this.stringURL = null;
                this.onurlchange();
                this.onstatechange(ServerStateKind.NEUTRAL, "Disconnected");
            }

            // N.B.: This behaves very similar to a setter for this.stringURL
            connect(url) {
                if (!url) {
                    this.disconnect();
                    return;
                }
                const stringURL = url.toString();
                if (this.stringURL !== stringURL) {
                    this.liveConnection?.abort();
                    this.stringURL = stringURL;
                    this.onurlchange();
                } else if (this.liveConnection) {
                    // Don't need to disconnect and reconnect if we are already connected to the right place.
                    return;
                }
                const candidateURL = URL.parse(HAS_PROTOCOL.test(stringURL) ? stringURL : "wss://" + stringURL);
                if (!candiateURL) {
                    this.onstatechange(ServerStateKind.BAD, "Invalid URL");
                    return;
                }
                this.credentials = { slotName: candidateURL.username, password: candidateURL.password };
                this.liveConnection = new AbortController();
                this.liveConnection.signal.addEventListener("abort", () => {
                    this.liveConnection = null;
                    this.idRanges = null;
                    this.datapackageChecksums = null;
                    this.socket.close();
                    this.socket = null;
                    this.credentials = null;
                }, { once: true });
                this.socket = this.#createSocket(candidateURL);
                this.onstatechange(ServerStateKind.NEUTRAL, "Connecting...");
            }

            #createSocket(url) {
                const socket = new WebSocket(url);
                socket.addEventListener("close", this.#closeHandler.bind(this), {
                    once: true,
                    signal: this.liveConnection.signal,
                });
                socket.addEventListener("open", this.#openHandler.bind(this), {
                    once: true,
                    signal: this.liveConnection.signal,
                });
                return socket;
            }

            #closeHandler() {
                if (this.datapackageChecksums) {
                    // We recieved the RoomInfo packet: this was an anomalous closure
                    this.liveConnection.abort();
                    this.onstatechange(ServerStateKind.BAD, "Connection closed unexpectedly");
                    return;
                }
                let url = new URL(this.socket.url);
                if (url.protocol === "ws:" || HAS_PROTOCOL.test(this.stringURL)) {
                    this.liveConnection.abort();
                    this.onstatechange(ServerStateKind.BAD, "Unable to connect");
                    return;
                }
                // Fall back to ws from wss
                url.protocol = "ws:";
                this.socket = this.#createSocket(url);
            }

            #openHandler() {
                this.socket.send(JSON.stringify({
                    cmd: "Connect",
                    name: this.credentials.slotName,
                    game: GAME_NAME,
                    password: this.credentials.password,
                    slot_data: true,
                    items_handling: 0b111 /* All items */,
                    uuid: CLIENT_UUID,
                    tags: ["NoText"],
                    version: { major: 0, minor: 6, build: 5, class: "Version" },
                }));
            }
        };
    </script>
</body>

</html>
